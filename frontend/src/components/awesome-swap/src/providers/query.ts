/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import type {
    MutationFunction,
    QueryFunction,
    QueryKey,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult
  } from '@tanstack/react-query'
  import {
    useMutation,
    useQuery
  } from '@tanstack/react-query'
  import type {
    AxiosError,
    AxiosRequestConfig,
    AxiosResponse
  } from 'axios'
  import axios from 'axios'
  import type {
    AcrossDomainDto,
    ActivityDto,
    ActivityV5Dto,
    BoolDto,
    BridgeConfigDto,
    BridgeControllerGetActivityParams,
    BridgeControllerGetBridgeConfigByDomainV4200,
    BridgeControllerGetCustomHyperlaneWarpRouteTokens200Item,
    BridgeControllerGetDeploymentTokens200Item,
    BridgeControllerGetDeploymentsParams,
    BridgeControllerGetGasPriceParams,
    BridgeControllerGetPaidDeploymentTokens200Item,
    BridgeControllerGetTokens200Item,
    BridgeControllerGetTokensParams,
    CctpDomainDto,
    ChainDto,
    ConduitDeploymentConfigDto,
    CreateConduitDeploymentDto,
    DeploymentDto,
    DeploymentsQueryDto,
    EstimateGasRequestDto,
    EstimateGasResponseDto,
    FiatPricesDto,
    GasPriceDto,
    GetActivityV5Dto,
    GetBridgeConfigV3Dto,
    GetBridgeConfigV4Dto,
    HyperlaneCustomWarpRouteFileRequestDto,
    HyperlaneCustomWarpRouteFileResponseDto,
    HyperlaneMailboxDto,
    IdDto,
    LzDomainDto,
    NumberDto,
    OldEstimateGasRequestDto,
    OldEstimateGasResponseDto,
    OnrampAssetsResponse,
    OnrampControllerGetQuotesParams,
    OnrampQuotesResponseDto,
    PricesDto,
    RouteRequestDto,
    RouteResponseDto,
    SuperbridgeConfigDto,
    SyncStatusDto,
    TransactionDto
  } from './model'
  
  
  
  
  export const bridgeControllerGetActivity = (
      address: string,
      params: BridgeControllerGetActivityParams, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<ActivityDto>> => {
      
      return axios.get(
        `/api/bridge/activity/${address}`,{
      ...options,
          params: {...params, ...options?.params},}
      );
    }
  
  
  export const getBridgeControllerGetActivityQueryKey = (address: string,
      params: BridgeControllerGetActivityParams,) => {
      return [`/api/bridge/activity/${address}`, ...(params ? [params]: [])] as const;
      }
  
      
  export const getBridgeControllerGetActivityQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError = AxiosError<unknown>>(address: string,
      params: BridgeControllerGetActivityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetActivityQueryKey(address,params);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetActivity>>> = ({ signal }) => bridgeControllerGetActivity(address,params, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetActivityQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivity>>>
  export type BridgeControllerGetActivityQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetActivity = <TData = Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError = AxiosError<unknown>>(
   address: string,
      params: BridgeControllerGetActivityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetActivityQueryOptions(address,params,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetActivityV5 = (
      getActivityV5Dto: GetActivityV5Dto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<ActivityV5Dto>> => {
      
      return axios.post(
        `/api/v5/bridge/activity`,
        getActivityV5Dto,options
      );
    }
  
  
  
  export const getBridgeControllerGetActivityV5MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV5>>, TError,{data: GetActivityV5Dto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV5>>, TError,{data: GetActivityV5Dto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetActivityV5>>, {data: GetActivityV5Dto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetActivityV5(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetActivityV5MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivityV5>>>
      export type BridgeControllerGetActivityV5MutationBody = GetActivityV5Dto
      export type BridgeControllerGetActivityV5MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetActivityV5 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV5>>, TError,{data: GetActivityV5Dto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetActivityV5>>,
          TError,
          {data: GetActivityV5Dto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetActivityV5MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetProveTransaction = (
      idDto: IdDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<TransactionDto>> => {
      
      return axios.post(
        `/api/bridge/op_prove`,
        idDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetProveTransactionMutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, {data: IdDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetProveTransaction(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetProveTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>>
      export type BridgeControllerGetProveTransactionMutationBody = IdDto
      export type BridgeControllerGetProveTransactionMutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetProveTransaction = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>,
          TError,
          {data: IdDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetProveTransactionMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetFinaliseTransaction = (
      idDto: IdDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<TransactionDto>> => {
      
      return axios.post(
        `/api/bridge/op_finalise`,
        idDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetFinaliseTransactionMutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, {data: IdDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetFinaliseTransaction(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetFinaliseTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>>
      export type BridgeControllerGetFinaliseTransactionMutationBody = IdDto
      export type BridgeControllerGetFinaliseTransactionMutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetFinaliseTransaction = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>,
          TError,
          {data: IdDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetFinaliseTransactionMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetArbitrumFinaliseTransactionV2 = (
      idDto: IdDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<TransactionDto>> => {
      
      return axios.post(
        `/api/bridge/arb_finalise`,
        idDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetArbitrumFinaliseTransactionV2MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, {data: IdDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetArbitrumFinaliseTransactionV2(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>>
      export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationBody = IdDto
      export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetArbitrumFinaliseTransactionV2 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>,
          TError,
          {data: IdDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetArbitrumFinaliseTransactionV2MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetCctpMintTransactionV2 = (
      idDto: IdDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<TransactionDto>> => {
      
      return axios.post(
        `/api/bridge/cctp_mint`,
        idDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetCctpMintTransactionV2MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, {data: IdDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetCctpMintTransactionV2(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetCctpMintTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>>
      export type BridgeControllerGetCctpMintTransactionV2MutationBody = IdDto
      export type BridgeControllerGetCctpMintTransactionV2MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetCctpMintTransactionV2 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>,
          TError,
          {data: IdDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetCctpMintTransactionV2MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetCctpV2MintTransaction = (
      idDto: IdDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<TransactionDto>> => {
      
      return axios.post(
        `/api/v1/bridge/cctp_mint_v2`,
        idDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetCctpV2MintTransactionMutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpV2MintTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpV2MintTransaction>>, TError,{data: IdDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpV2MintTransaction>>, {data: IdDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetCctpV2MintTransaction(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetCctpV2MintTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpV2MintTransaction>>>
      export type BridgeControllerGetCctpV2MintTransactionMutationBody = IdDto
      export type BridgeControllerGetCctpV2MintTransactionMutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetCctpV2MintTransaction = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpV2MintTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetCctpV2MintTransaction>>,
          TError,
          {data: IdDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetCctpV2MintTransactionMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetOpInteropRelayTransaction = (
      idDto: IdDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<TransactionDto>> => {
      
      return axios.post(
        `/api/bridge/op_interop_relay`,
        idDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetOpInteropRelayTransactionMutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetOpInteropRelayTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetOpInteropRelayTransaction>>, TError,{data: IdDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetOpInteropRelayTransaction>>, {data: IdDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetOpInteropRelayTransaction(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetOpInteropRelayTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetOpInteropRelayTransaction>>>
      export type BridgeControllerGetOpInteropRelayTransactionMutationBody = IdDto
      export type BridgeControllerGetOpInteropRelayTransactionMutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetOpInteropRelayTransaction = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetOpInteropRelayTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetOpInteropRelayTransaction>>,
          TError,
          {data: IdDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetOpInteropRelayTransactionMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerFiatPrices = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<FiatPricesDto>> => {
      
      return axios.get(
        `/api/bridge/fiat_prices`,options
      );
    }
  
  
  export const getBridgeControllerFiatPricesQueryKey = () => {
      return [`/api/bridge/fiat_prices`] as const;
      }
  
      
  export const getBridgeControllerFiatPricesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerFiatPricesQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>> = ({ signal }) => bridgeControllerFiatPrices({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerFiatPricesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>>
  export type BridgeControllerFiatPricesQueryError = AxiosError<unknown>
  
  export const useBridgeControllerFiatPrices = <TData = Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerFiatPricesQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetTokenPrices = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<PricesDto>> => {
      
      return axios.get(
        `/api/bridge/token_prices`,options
      );
    }
  
  
  export const getBridgeControllerGetTokenPricesQueryKey = () => {
      return [`/api/bridge/token_prices`] as const;
      }
  
      
  export const getBridgeControllerGetTokenPricesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetTokenPricesQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>> = ({ signal }) => bridgeControllerGetTokenPrices({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetTokenPricesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>>
  export type BridgeControllerGetTokenPricesQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetTokenPrices = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetTokenPricesQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetDeployments = (
      params?: BridgeControllerGetDeploymentsParams, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<DeploymentDto[]>> => {
      
      return axios.get(
        `/api/bridge/deployments`,{
      ...options,
          params: {...params, ...options?.params},}
      );
    }
  
  
  export const getBridgeControllerGetDeploymentsQueryKey = (params?: BridgeControllerGetDeploymentsParams,) => {
      return [`/api/bridge/deployments`, ...(params ? [params]: [])] as const;
      }
  
      
  export const getBridgeControllerGetDeploymentsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError = AxiosError<unknown>>(params?: BridgeControllerGetDeploymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentsQueryKey(params);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>> = ({ signal }) => bridgeControllerGetDeployments(params, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetDeploymentsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>>
  export type BridgeControllerGetDeploymentsQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetDeployments = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError = AxiosError<unknown>>(
   params?: BridgeControllerGetDeploymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetDeploymentsQueryOptions(params,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetDeploymentsV2 = (
      deploymentsQueryDto: DeploymentsQueryDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<DeploymentDto[]>> => {
      
      return axios.post(
        `/api/bridge/deployments`,
        deploymentsQueryDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetDeploymentsV2MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, {data: DeploymentsQueryDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetDeploymentsV2(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetDeploymentsV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>>
      export type BridgeControllerGetDeploymentsV2MutationBody = DeploymentsQueryDto
      export type BridgeControllerGetDeploymentsV2MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetDeploymentsV2 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>,
          TError,
          {data: DeploymentsQueryDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetDeploymentsV2MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetDeploymentsByDomain = (
      domain: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<DeploymentDto[]>> => {
      
      return axios.get(
        `/api/bridge/deployments_by_domain/${domain}`,options
      );
    }
  
  
  export const getBridgeControllerGetDeploymentsByDomainQueryKey = (domain: string,) => {
      return [`/api/bridge/deployments_by_domain/${domain}`] as const;
      }
  
      
  export const getBridgeControllerGetDeploymentsByDomainQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentsByDomainQueryKey(domain);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>> = ({ signal }) => bridgeControllerGetDeploymentsByDomain(domain, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetDeploymentsByDomainQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>>
  export type BridgeControllerGetDeploymentsByDomainQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetDeploymentsByDomain = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError = AxiosError<unknown>>(
   domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetDeploymentsByDomainQueryOptions(domain,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetCctpDomains = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<CctpDomainDto[]>> => {
      
      return axios.get(
        `/api/bridge/cctp_domains`,options
      );
    }
  
  
  export const getBridgeControllerGetCctpDomainsQueryKey = () => {
      return [`/api/bridge/cctp_domains`] as const;
      }
  
      
  export const getBridgeControllerGetCctpDomainsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetCctpDomainsQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>> = ({ signal }) => bridgeControllerGetCctpDomains({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetCctpDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>>
  export type BridgeControllerGetCctpDomainsQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetCctpDomains = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetCctpDomainsQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetAcrossDomains = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<AcrossDomainDto[]>> => {
      
      return axios.get(
        `/api/bridge/across_domains`,options
      );
    }
  
  
  export const getBridgeControllerGetAcrossDomainsQueryKey = () => {
      return [`/api/bridge/across_domains`] as const;
      }
  
      
  export const getBridgeControllerGetAcrossDomainsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetAcrossDomainsQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>> = ({ signal }) => bridgeControllerGetAcrossDomains({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetAcrossDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>>
  export type BridgeControllerGetAcrossDomainsQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetAcrossDomains = <TData = Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetAcrossDomainsQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetHyperlaneMailboxes = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<HyperlaneMailboxDto[]>> => {
      
      return axios.get(
        `/api/bridge/hyperlane_mailboxes`,options
      );
    }
  
  
  export const getBridgeControllerGetHyperlaneMailboxesQueryKey = () => {
      return [`/api/bridge/hyperlane_mailboxes`] as const;
      }
  
      
  export const getBridgeControllerGetHyperlaneMailboxesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetHyperlaneMailboxesQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>> = ({ signal }) => bridgeControllerGetHyperlaneMailboxes({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetHyperlaneMailboxesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>>
  export type BridgeControllerGetHyperlaneMailboxesQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetHyperlaneMailboxes = <TData = Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetHyperlaneMailboxesQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetLzDomains = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<LzDomainDto[]>> => {
      
      return axios.get(
        `/api/bridge/lz_domains`,options
      );
    }
  
  
  export const getBridgeControllerGetLzDomainsQueryKey = () => {
      return [`/api/bridge/lz_domains`] as const;
      }
  
      
  export const getBridgeControllerGetLzDomainsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetLzDomainsQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>> = ({ signal }) => bridgeControllerGetLzDomains({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetLzDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>>
  export type BridgeControllerGetLzDomainsQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetLzDomains = <TData = Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLzDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetLzDomainsQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetChains = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<ChainDto[]>> => {
      
      return axios.get(
        `/api/bridge/chains`,options
      );
    }
  
  
  export const getBridgeControllerGetChainsQueryKey = () => {
      return [`/api/bridge/chains`] as const;
      }
  
      
  export const getBridgeControllerGetChainsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetChains>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetChains>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetChainsQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetChains>>> = ({ signal }) => bridgeControllerGetChains({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetChains>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetChainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetChains>>>
  export type BridgeControllerGetChainsQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetChains = <TData = Awaited<ReturnType<typeof bridgeControllerGetChains>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetChains>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetChainsQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetStatus = (
      address: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BoolDto>> => {
      
      return axios.get(
        `/api/bridge/status/${address}`,options
      );
    }
  
  
  export const getBridgeControllerGetStatusQueryKey = (address: string,) => {
      return [`/api/bridge/status/${address}`] as const;
      }
  
      
  export const getBridgeControllerGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError = AxiosError<unknown>>(address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetStatusQueryKey(address);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetStatus>>> = ({ signal }) => bridgeControllerGetStatus(address, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetStatus>>>
  export type BridgeControllerGetStatusQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError = AxiosError<unknown>>(
   address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetStatusQueryOptions(address,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetLatestStateRoot = (
      deploymentId: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<NumberDto>> => {
      
      return axios.get(
        `/api/bridge/latest_state_root/${deploymentId}`,options
      );
    }
  
  
  export const getBridgeControllerGetLatestStateRootQueryKey = (deploymentId: string,) => {
      return [`/api/bridge/latest_state_root/${deploymentId}`] as const;
      }
  
      
  export const getBridgeControllerGetLatestStateRootQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetLatestStateRootQueryKey(deploymentId);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>> = ({ signal }) => bridgeControllerGetLatestStateRoot(deploymentId, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetLatestStateRootQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>>
  export type BridgeControllerGetLatestStateRootQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetLatestStateRoot = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError = AxiosError<unknown>>(
   deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetLatestStateRootQueryOptions(deploymentId,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetLatestDisputeGame = (
      deploymentId: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<NumberDto>> => {
      
      return axios.get(
        `/api/bridge/latest_dispute_game/${deploymentId}`,options
      );
    }
  
  
  export const getBridgeControllerGetLatestDisputeGameQueryKey = (deploymentId: string,) => {
      return [`/api/bridge/latest_dispute_game/${deploymentId}`] as const;
      }
  
      
  export const getBridgeControllerGetLatestDisputeGameQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetLatestDisputeGameQueryKey(deploymentId);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>> = ({ signal }) => bridgeControllerGetLatestDisputeGame(deploymentId, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetLatestDisputeGameQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>>
  export type BridgeControllerGetLatestDisputeGameQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetLatestDisputeGame = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError = AxiosError<unknown>>(
   deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetLatestDisputeGameQueryOptions(deploymentId,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetSuperbridgeConfig = (
       options?: AxiosRequestConfig
   ): Promise<AxiosResponse<SuperbridgeConfigDto>> => {
      
      return axios.get(
        `/api/bridge/superbridge_config`,options
      );
    }
  
  
  export const getBridgeControllerGetSuperbridgeConfigQueryKey = () => {
      return [`/api/bridge/superbridge_config`] as const;
      }
  
      
  export const getBridgeControllerGetSuperbridgeConfigQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetSuperbridgeConfigQueryKey();
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>> = ({ signal }) => bridgeControllerGetSuperbridgeConfig({ signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetSuperbridgeConfigQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>>
  export type BridgeControllerGetSuperbridgeConfigQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetSuperbridgeConfig = <TData = Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError = AxiosError<unknown>>(
    options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetSuperbridgeConfigQueryOptions(options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetBridgeRoutesV2 = (
      routeRequestDto: RouteRequestDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<RouteResponseDto>> => {
      
      return axios.post(
        `/api/v2/bridge/routes`,
        routeRequestDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetBridgeRoutesV2MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutesV2>>, TError,{data: RouteRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutesV2>>, TError,{data: RouteRequestDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutesV2>>, {data: RouteRequestDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetBridgeRoutesV2(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetBridgeRoutesV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutesV2>>>
      export type BridgeControllerGetBridgeRoutesV2MutationBody = RouteRequestDto
      export type BridgeControllerGetBridgeRoutesV2MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetBridgeRoutesV2 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutesV2>>, TError,{data: RouteRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutesV2>>,
          TError,
          {data: RouteRequestDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetBridgeRoutesV2MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetTokens = (
      domain: string,
      params?: BridgeControllerGetTokensParams, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeControllerGetTokens200Item[]>> => {
      
      return axios.get(
        `/api/bridge/tokens/${domain}`,{
      ...options,
          params: {...params, ...options?.params},}
      );
    }
  
  
  export const getBridgeControllerGetTokensQueryKey = (domain: string,
      params?: BridgeControllerGetTokensParams,) => {
      return [`/api/bridge/tokens/${domain}`, ...(params ? [params]: [])] as const;
      }
  
      
  export const getBridgeControllerGetTokensQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError = AxiosError<unknown>>(domain: string,
      params?: BridgeControllerGetTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetTokensQueryKey(domain,params);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetTokens>>> = ({ signal }) => bridgeControllerGetTokens(domain,params, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetTokensQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetTokens>>>
  export type BridgeControllerGetTokensQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetTokens = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError = AxiosError<unknown>>(
   domain: string,
      params?: BridgeControllerGetTokensParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetTokensQueryOptions(domain,params,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetPaidDeploymentTokens = (
      tokensId: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeControllerGetPaidDeploymentTokens200Item[]>> => {
      
      return axios.get(
        `/api/v2/bridge/paid_deployment_tokens/${tokensId}`,options
      );
    }
  
  
  export const getBridgeControllerGetPaidDeploymentTokensQueryKey = (tokensId: string,) => {
      return [`/api/v2/bridge/paid_deployment_tokens/${tokensId}`] as const;
      }
  
      
  export const getBridgeControllerGetPaidDeploymentTokensQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>, TError = AxiosError<unknown>>(tokensId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetPaidDeploymentTokensQueryKey(tokensId);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>> = ({ signal }) => bridgeControllerGetPaidDeploymentTokens(tokensId, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(tokensId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetPaidDeploymentTokensQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>>
  export type BridgeControllerGetPaidDeploymentTokensQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetPaidDeploymentTokens = <TData = Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>, TError = AxiosError<unknown>>(
   tokensId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetPaidDeploymentTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetPaidDeploymentTokensQueryOptions(tokensId,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetDeploymentTokens = (
      deploymentId: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeControllerGetDeploymentTokens200Item[]>> => {
      
      return axios.get(
        `/api/v2/bridge/deployment_tokens/${deploymentId}`,options
      );
    }
  
  
  export const getBridgeControllerGetDeploymentTokensQueryKey = (deploymentId: string,) => {
      return [`/api/v2/bridge/deployment_tokens/${deploymentId}`] as const;
      }
  
      
  export const getBridgeControllerGetDeploymentTokensQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentTokensQueryKey(deploymentId);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>> = ({ signal }) => bridgeControllerGetDeploymentTokens(deploymentId, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetDeploymentTokensQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>>
  export type BridgeControllerGetDeploymentTokensQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetDeploymentTokens = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>, TError = AxiosError<unknown>>(
   deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetDeploymentTokensQueryOptions(deploymentId,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetCustomHyperlaneWarpRouteTokens = (
      tokensId: string,
      customWarpRoutesId: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeControllerGetCustomHyperlaneWarpRouteTokens200Item[]>> => {
      
      return axios.get(
        `/api/v2/bridge/custom_warp_route_tokens/${tokensId}/${customWarpRoutesId}`,options
      );
    }
  
  
  export const getBridgeControllerGetCustomHyperlaneWarpRouteTokensQueryKey = (tokensId: string,
      customWarpRoutesId: string,) => {
      return [`/api/v2/bridge/custom_warp_route_tokens/${tokensId}/${customWarpRoutesId}`] as const;
      }
  
      
  export const getBridgeControllerGetCustomHyperlaneWarpRouteTokensQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>, TError = AxiosError<unknown>>(tokensId: string,
      customWarpRoutesId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetCustomHyperlaneWarpRouteTokensQueryKey(tokensId,customWarpRoutesId);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>> = ({ signal }) => bridgeControllerGetCustomHyperlaneWarpRouteTokens(tokensId,customWarpRoutesId, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(tokensId && customWarpRoutesId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetCustomHyperlaneWarpRouteTokensQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>>
  export type BridgeControllerGetCustomHyperlaneWarpRouteTokensQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetCustomHyperlaneWarpRouteTokens = <TData = Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>, TError = AxiosError<unknown>>(
   tokensId: string,
      customWarpRoutesId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCustomHyperlaneWarpRouteTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetCustomHyperlaneWarpRouteTokensQueryOptions(tokensId,customWarpRoutesId,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetBridgeConfigByDomainV2 = (
      domain: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeConfigDto>> => {
      
      return axios.get(
        `/api/v2/bridge/bridge_config/${domain}`,options
      );
    }
  
  
  export const getBridgeControllerGetBridgeConfigByDomainV2QueryKey = (domain: string,) => {
      return [`/api/v2/bridge/bridge_config/${domain}`] as const;
      }
  
      
  export const getBridgeControllerGetBridgeConfigByDomainV2QueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetBridgeConfigByDomainV2QueryKey(domain);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>> = ({ signal }) => bridgeControllerGetBridgeConfigByDomainV2(domain, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetBridgeConfigByDomainV2QueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>>
  export type BridgeControllerGetBridgeConfigByDomainV2QueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetBridgeConfigByDomainV2 = <TData = Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError = AxiosError<unknown>>(
   domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetBridgeConfigByDomainV2QueryOptions(domain,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetBridgeConfigByDomainV3 = (
      getBridgeConfigV3Dto: GetBridgeConfigV3Dto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeConfigDto>> => {
      
      return axios.post(
        `/api/v3/bridge/bridge_config`,
        getBridgeConfigV3Dto,options
      );
    }
  
  
  
  export const getBridgeControllerGetBridgeConfigByDomainV3MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV3>>, TError,{data: GetBridgeConfigV3Dto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV3>>, TError,{data: GetBridgeConfigV3Dto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV3>>, {data: GetBridgeConfigV3Dto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetBridgeConfigByDomainV3(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetBridgeConfigByDomainV3MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV3>>>
      export type BridgeControllerGetBridgeConfigByDomainV3MutationBody = GetBridgeConfigV3Dto
      export type BridgeControllerGetBridgeConfigByDomainV3MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetBridgeConfigByDomainV3 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV3>>, TError,{data: GetBridgeConfigV3Dto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV3>>,
          TError,
          {data: GetBridgeConfigV3Dto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetBridgeConfigByDomainV3MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetBridgeConfigByDomainV4 = (
      getBridgeConfigV4Dto: GetBridgeConfigV4Dto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<BridgeControllerGetBridgeConfigByDomainV4200>> => {
      
      return axios.post(
        `/api/v4/bridge/bridge_config`,
        getBridgeConfigV4Dto,options
      );
    }
  
  
  
  export const getBridgeControllerGetBridgeConfigByDomainV4MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV4>>, TError,{data: GetBridgeConfigV4Dto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV4>>, TError,{data: GetBridgeConfigV4Dto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV4>>, {data: GetBridgeConfigV4Dto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetBridgeConfigByDomainV4(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetBridgeConfigByDomainV4MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV4>>>
      export type BridgeControllerGetBridgeConfigByDomainV4MutationBody = GetBridgeConfigV4Dto
      export type BridgeControllerGetBridgeConfigByDomainV4MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetBridgeConfigByDomainV4 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV4>>, TError,{data: GetBridgeConfigV4Dto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV4>>,
          TError,
          {data: GetBridgeConfigV4Dto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetBridgeConfigByDomainV4MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetDeploymentSyncStatus = (
      deploymentId: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<SyncStatusDto[]>> => {
      
      return axios.get(
        `/api/bridge/sync_status/${deploymentId}`,options
      );
    }
  
  
  export const getBridgeControllerGetDeploymentSyncStatusQueryKey = (deploymentId: string,) => {
      return [`/api/bridge/sync_status/${deploymentId}`] as const;
      }
  
      
  export const getBridgeControllerGetDeploymentSyncStatusQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentSyncStatusQueryKey(deploymentId);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>> = ({ signal }) => bridgeControllerGetDeploymentSyncStatus(deploymentId, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetDeploymentSyncStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>>
  export type BridgeControllerGetDeploymentSyncStatusQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetDeploymentSyncStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError = AxiosError<unknown>>(
   deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetDeploymentSyncStatusQueryOptions(deploymentId,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerGetGasEstimate = (
      oldEstimateGasRequestDto: OldEstimateGasRequestDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<OldEstimateGasResponseDto>> => {
      
      return axios.post(
        `/api/v1/bridge/estimate_gas`,
        oldEstimateGasRequestDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetGasEstimateMutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetGasEstimate>>, TError,{data: OldEstimateGasRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetGasEstimate>>, TError,{data: OldEstimateGasRequestDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetGasEstimate>>, {data: OldEstimateGasRequestDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetGasEstimate(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetGasEstimateMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetGasEstimate>>>
      export type BridgeControllerGetGasEstimateMutationBody = OldEstimateGasRequestDto
      export type BridgeControllerGetGasEstimateMutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetGasEstimate = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetGasEstimate>>, TError,{data: OldEstimateGasRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetGasEstimate>>,
          TError,
          {data: OldEstimateGasRequestDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetGasEstimateMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetGasEstimateV2 = (
      estimateGasRequestDto: EstimateGasRequestDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<EstimateGasResponseDto>> => {
      
      return axios.post(
        `/api/v2/bridge/estimate_gas`,
        estimateGasRequestDto,options
      );
    }
  
  
  
  export const getBridgeControllerGetGasEstimateV2MutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetGasEstimateV2>>, TError,{data: EstimateGasRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetGasEstimateV2>>, TError,{data: EstimateGasRequestDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetGasEstimateV2>>, {data: EstimateGasRequestDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerGetGasEstimateV2(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerGetGasEstimateV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetGasEstimateV2>>>
      export type BridgeControllerGetGasEstimateV2MutationBody = EstimateGasRequestDto
      export type BridgeControllerGetGasEstimateV2MutationError = AxiosError<unknown>
  
      export const useBridgeControllerGetGasEstimateV2 = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetGasEstimateV2>>, TError,{data: EstimateGasRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerGetGasEstimateV2>>,
          TError,
          {data: EstimateGasRequestDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerGetGasEstimateV2MutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetGasPrice = (
      domain: string,
      chainId: string,
      params?: BridgeControllerGetGasPriceParams, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<GasPriceDto>> => {
      
      return axios.get(
        `/api/v1/bridge/gas_price/${domain}/${chainId}`,{
      ...options,
          params: {...params, ...options?.params},}
      );
    }
  
  
  export const getBridgeControllerGetGasPriceQueryKey = (domain: string,
      chainId: string,
      params?: BridgeControllerGetGasPriceParams,) => {
      return [`/api/v1/bridge/gas_price/${domain}/${chainId}`, ...(params ? [params]: [])] as const;
      }
  
      
  export const getBridgeControllerGetGasPriceQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>, TError = AxiosError<unknown>>(domain: string,
      chainId: string,
      params?: BridgeControllerGetGasPriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetGasPriceQueryKey(domain,chainId,params);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>> = ({ signal }) => bridgeControllerGetGasPrice(domain,chainId,params, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(domain && chainId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetGasPriceQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>>
  export type BridgeControllerGetGasPriceQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetGasPrice = <TData = Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>, TError = AxiosError<unknown>>(
   domain: string,
      chainId: string,
      params?: BridgeControllerGetGasPriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetGasPrice>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetGasPriceQueryOptions(domain,chainId,params,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const bridgeControllerCreateConduitDeployment = (
      createConduitDeploymentDto: CreateConduitDeploymentDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<ConduitDeploymentConfigDto>> => {
      
      return axios.post(
        `/api/bridge/conduit/deployment`,
        createConduitDeploymentDto,options
      );
    }
  
  
  
  export const getBridgeControllerCreateConduitDeploymentMutationOptions = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, {data: CreateConduitDeploymentDto}> = (props) => {
            const {data} = props ?? {};
  
            return  bridgeControllerCreateConduitDeployment(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type BridgeControllerCreateConduitDeploymentMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>>
      export type BridgeControllerCreateConduitDeploymentMutationBody = CreateConduitDeploymentDto
      export type BridgeControllerCreateConduitDeploymentMutationError = AxiosError<unknown>
  
      export const useBridgeControllerCreateConduitDeployment = <TError = AxiosError<unknown>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>,
          TError,
          {data: CreateConduitDeploymentDto},
          TContext
        > => {
  
        const mutationOptions = getBridgeControllerCreateConduitDeploymentMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const bridgeControllerGetConduitDeployment = (
      id: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<ConduitDeploymentConfigDto>> => {
      
      return axios.get(
        `/api/bridge/conduit/deployment/${id}`,options
      );
    }
  
  
  export const getBridgeControllerGetConduitDeploymentQueryKey = (id: string,) => {
      return [`/api/bridge/conduit/deployment/${id}`] as const;
      }
  
      
  export const getBridgeControllerGetConduitDeploymentQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetConduitDeploymentQueryKey(id);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>> = ({ signal }) => bridgeControllerGetConduitDeployment(id, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type BridgeControllerGetConduitDeploymentQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>>
  export type BridgeControllerGetConduitDeploymentQueryError = AxiosError<unknown>
  
  export const useBridgeControllerGetConduitDeployment = <TData = Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError = AxiosError<unknown>>(
   id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getBridgeControllerGetConduitDeploymentQueryOptions(id,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const hyperlaneControllerResolveWarpRouteYamlFile = (
      hyperlaneCustomWarpRouteFileRequestDto: HyperlaneCustomWarpRouteFileRequestDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<HyperlaneCustomWarpRouteFileResponseDto>> => {
      
      return axios.post(
        `/api/hyperlane/resolve_warp_route_yaml_file`,
        hyperlaneCustomWarpRouteFileRequestDto,options
      );
    }
  
  
  
  export const getHyperlaneControllerResolveWarpRouteYamlFileMutationOptions = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, {data: HyperlaneCustomWarpRouteFileRequestDto}> = (props) => {
            const {data} = props ?? {};
  
            return  hyperlaneControllerResolveWarpRouteYamlFile(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type HyperlaneControllerResolveWarpRouteYamlFileMutationResult = NonNullable<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>>
      export type HyperlaneControllerResolveWarpRouteYamlFileMutationBody = HyperlaneCustomWarpRouteFileRequestDto
      export type HyperlaneControllerResolveWarpRouteYamlFileMutationError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>
  
      export const useHyperlaneControllerResolveWarpRouteYamlFile = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>,
          TError,
          {data: HyperlaneCustomWarpRouteFileRequestDto},
          TContext
        > => {
  
        const mutationOptions = getHyperlaneControllerResolveWarpRouteYamlFileMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const hyperlaneControllerSaveWarpRouteYamlFile = (
      hyperlaneCustomWarpRouteFileRequestDto: HyperlaneCustomWarpRouteFileRequestDto, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<IdDto>> => {
      
      return axios.post(
        `/api/hyperlane/custom_routes`,
        hyperlaneCustomWarpRouteFileRequestDto,options
      );
    }
  
  
  
  export const getHyperlaneControllerSaveWarpRouteYamlFileMutationOptions = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext> => {
  const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};
  
        
  
  
        const mutationFn: MutationFunction<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, {data: HyperlaneCustomWarpRouteFileRequestDto}> = (props) => {
            const {data} = props ?? {};
  
            return  hyperlaneControllerSaveWarpRouteYamlFile(data,axiosOptions)
          }
  
          
  
  
    return  { mutationFn, ...mutationOptions }}
  
      export type HyperlaneControllerSaveWarpRouteYamlFileMutationResult = NonNullable<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>>
      export type HyperlaneControllerSaveWarpRouteYamlFileMutationBody = HyperlaneCustomWarpRouteFileRequestDto
      export type HyperlaneControllerSaveWarpRouteYamlFileMutationError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>
  
      export const useHyperlaneControllerSaveWarpRouteYamlFile = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
      TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
  ): UseMutationResult<
          Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>,
          TError,
          {data: HyperlaneCustomWarpRouteFileRequestDto},
          TContext
        > => {
  
        const mutationOptions = getHyperlaneControllerSaveWarpRouteYamlFileMutationOptions(options);
  
        return useMutation(mutationOptions);
      }
      
  export const hyperlaneControllerGetWarpRouteYamlFile = (
      id: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<HyperlaneCustomWarpRouteFileResponseDto>> => {
      
      return axios.get(
        `/api/hyperlane/custom_routes/${id}`,options
      );
    }
  
  
  export const getHyperlaneControllerGetWarpRouteYamlFileQueryKey = (id: string,) => {
      return [`/api/hyperlane/custom_routes/${id}`] as const;
      }
  
      
  export const getHyperlaneControllerGetWarpRouteYamlFileQueryOptions = <TData = Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getHyperlaneControllerGetWarpRouteYamlFileQueryKey(id);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>> = ({ signal }) => hyperlaneControllerGetWarpRouteYamlFile(id, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type HyperlaneControllerGetWarpRouteYamlFileQueryResult = NonNullable<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>>
  export type HyperlaneControllerGetWarpRouteYamlFileQueryError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>
  
  export const useHyperlaneControllerGetWarpRouteYamlFile = <TData = Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>>(
   id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getHyperlaneControllerGetWarpRouteYamlFileQueryOptions(id,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const onrampControllerGetSupportedAssets = (
      domain: string, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<OnrampAssetsResponse>> => {
      
      return axios.get(
        `/api/v1/onramp/supported_assets/${domain}`,options
      );
    }
  
  
  export const getOnrampControllerGetSupportedAssetsQueryKey = (domain: string,) => {
      return [`/api/v1/onramp/supported_assets/${domain}`] as const;
      }
  
      
  export const getOnrampControllerGetSupportedAssetsQueryOptions = <TData = Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getOnrampControllerGetSupportedAssetsQueryKey(domain);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>> = ({ signal }) => onrampControllerGetSupportedAssets(domain, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type OnrampControllerGetSupportedAssetsQueryResult = NonNullable<Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>>
  export type OnrampControllerGetSupportedAssetsQueryError = AxiosError<unknown>
  
  export const useOnrampControllerGetSupportedAssets = <TData = Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>, TError = AxiosError<unknown>>(
   domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onrampControllerGetSupportedAssets>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getOnrampControllerGetSupportedAssetsQueryOptions(domain,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  export const onrampControllerGetQuotes = (
      domain: string,
      params: OnrampControllerGetQuotesParams, options?: AxiosRequestConfig
   ): Promise<AxiosResponse<OnrampQuotesResponseDto>> => {
      
      return axios.get(
        `/api/v1/onramp/quote/${domain}`,{
      ...options,
          params: {...params, ...options?.params},}
      );
    }
  
  
  export const getOnrampControllerGetQuotesQueryKey = (domain: string,
      params: OnrampControllerGetQuotesParams,) => {
      return [`/api/v1/onramp/quote/${domain}`, ...(params ? [params]: [])] as const;
      }
  
      
  export const getOnrampControllerGetQuotesQueryOptions = <TData = Awaited<ReturnType<typeof onrampControllerGetQuotes>>, TError = AxiosError<unknown>>(domain: string,
      params: OnrampControllerGetQuotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onrampControllerGetQuotes>>, TError, TData>>, axios?: AxiosRequestConfig}
  ) => {
  
  const {query: queryOptions, axios: axiosOptions} = options ?? {};
  
    const queryKey =  queryOptions?.queryKey ?? getOnrampControllerGetQuotesQueryKey(domain,params);
  
    
  
      const queryFn: QueryFunction<Awaited<ReturnType<typeof onrampControllerGetQuotes>>> = ({ signal }) => onrampControllerGetQuotes(domain,params, { signal, ...axiosOptions });
  
        
  
        
  
     return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof onrampControllerGetQuotes>>, TError, TData> & { queryKey: QueryKey }
  }
  
  export type OnrampControllerGetQuotesQueryResult = NonNullable<Awaited<ReturnType<typeof onrampControllerGetQuotes>>>
  export type OnrampControllerGetQuotesQueryError = AxiosError<unknown>
  
  export const useOnrampControllerGetQuotes = <TData = Awaited<ReturnType<typeof onrampControllerGetQuotes>>, TError = AxiosError<unknown>>(
   domain: string,
      params: OnrampControllerGetQuotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onrampControllerGetQuotes>>, TError, TData>>, axios?: AxiosRequestConfig}
  
    ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  
    const queryOptions = getOnrampControllerGetQuotesQueryOptions(domain,params,options)
  
    const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };
  
    query.queryKey = queryOptions.queryKey ;
  
    return query;
  }
  
  
  
  
  