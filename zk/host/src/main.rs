use std::sync::Arc;

use axum::routing::{ get, post };
use axum::Router;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use db::{ establish_connection };

use db::{
    get_all_cars_handler,
    create_auction,
    create_bid,
    create_car,
    get_auction_by_id,
    get_auctions,
    get_bid_by_id,
    get_bids,
    get_car_by_id,
};

use host::overall::init_overall_handler;
use host::auction::init_auction_handler;
use host::bid::init_bid_handler;
use host::car::init_car_handler;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let db = establish_connection("postgres://kaleel:kaleel@127.0.0.1:5432/zero").await?;
    let db = Arc::new(db);
    // let cars = get_all_cars(&db).await.unwrap();
    // get_car_merkle_hash(cars);
    // let leaves = get_car_leaves(&cars);

    // Create the router with our endpoints
    let app = Router::new()
        .route("/api/cars/{id}", get(get_car_by_id))
        .route("/api/cars", get(get_all_cars_handler))
        .route("/api/cars", post(create_car))
        .route("/api/auctions", get(get_auctions))
        .route("/api/auctions", post(create_auction))
        .route("/api/auctions/{id}", get(get_auction_by_id))
        .route("/api/bids", get(get_bids))
        .route("/api/bids", post(create_bid))
        .route("/api/bids/{id}", get(get_bid_by_id))
        //init
        .route("/api/auctions/init", get(init_auction_handler))
        .route("/api/cars/init", get(init_car_handler))
        .route("/api/bids/init", get(init_bid_handler))
        .route("/api/db/init", get(init_overall_handler))
        .with_state(db);

    // Now you can use the entity types directly
    // for car in cars {
    //     println!("Car: {:?}", car);
    // }

    // print!("cars: {:?}", cars);
    // get_car_merkle_hash();
    // let db = Arc::new(db);
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber
        ::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    // let input: u32 = 15 * u32::pow(2, 27) + 1;
    // let input = get_car_leaves(cars)[0];
    // let env = ExecutorEnv::builder().write(&leaves).unwrap().build().unwrap();

    // Obtain the default prover.
    // let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover.prove(env, INIT_ELF).unwrap();

    // extract the receipt.
    // let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    // let output: AuctionState = receipt.journal.decode().unwrap();
    // print!("{:?}", output);
    // print!("{:?}", receipt);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    // receipt.verify(INIT_ID).unwrap();
    // Start the server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("Server running on http://0.0.0.0:3000");
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

// fn get_car_merkle_hash(cars: Vec<CarModel>) {
//     let mut leaves = vec![];
//     // let tree: Vec<&'static str> = vec!["s", "ss"];
//     for car in cars {
//         let car_record = format!(
//             "{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{:?}:{}:{}",
//             car.id,
//             car.make,
//             car.model,
//             car.year,
//             car.color,
//             car.mileage,
//             car.vin,
//             car.transmission,
//             car.fuel_type,
//             car.engine_size,
//             car.exterior_color,
//             car.interior_color,
//             car.odometer,
//             car.description,
//             car.image_url,
//             car.auction_id,
//             car.starting_price,
//             car.current_price,
//             car.auction_status.clone().unwrap(),
//             // "status"
//             car.created_at.and_utc().timestamp(),
//             car.updated_at.and_utc().timestamp()
//         );
//         // car_record = format!("{{}}:{}:{}", id, id);
//         print!("{} \n", car_record);
//         leaves.push(sha256(car_record.as_bytes()));
//     }
//     // let le = format!(leaves.iter());
//     print!("{:?}", leaves[0])

//     // Ok(())
// }
