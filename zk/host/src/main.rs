use std::sync::Arc;

use axum::routing::{ get, post };
use axum::Router;
use car_auction_core::VerifyParams;
use db::comment::{ create_comment, get_comments };
use db::saved_auction::{ create_saved_auction, get_saved_auctions, get_saved_auctions_by_user };
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use db::{ establish_connection };

use db::{
    car::{ get_all_cars_handler, create_car, get_car_by_id },
    auction::{ get_auction_by_id, get_auctions, create_auction },
    bid::{ get_bid_by_id, get_bids, create_bid },
};

use hex_literal::hex;

use host::overall::init_overall_handler;
use host::auction::init_auction_handler;
use host::bid::init_bid_handler;
use host::car::init_car_handler;
use methods::VERIFY_ELF;
use risc0_zkvm::{ default_prover, ExecutorEnv, ExecutorEnvBuilder };

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let db = establish_connection("postgres://kaleel:kaleel@127.0.0.1:5432/zero").await?;
    let db = Arc::new(db);
    // let cars = get_all_cars(&db).await.unwrap();
    // get_car_merkle_hash(cars);
    // let leaves = get_car_leaves(&cars);
    let message = "Authenticate me, please".to_string(); // type: &[u8]

    // Ethereum-style address (20 bytes)
    let address: [u8; 20] = hex!("90f8bf6a479f320ead074411a4b0e7944ea8c9c1");

    // Mock signature (65 bytes: r(32) + s(32) + v(1))
    let signature: [u8; 65] = hex!(
        "5f6e8aef9b4c7d78cda3f6bdcc92f5b8a6f4e8f7bb8eb8b93dc6d3dce8c5a9e6
         6ed8fcdfe567c68c9f1f8aa2f75cbffb17b07fc7b82739c8be789f5c14f11b0c
         1c"
    );
    let verify_params = VerifyParams {
        message,
        signature_bytes: signature.to_vec(),
        expected_addr: address.to_vec(),
    };
    let env = ExecutorEnv::builder().write(&verify_params).unwrap().build().unwrap();
    let prover = default_prover();
    let prove_info = prover.prove(env, VERIFY_ELF).unwrap();
    // let verify_commit = prove.info
    // Ok(auction_commit);

    // Create the router with our endpoints
    let app = Router::new()
        .route("/api/cars/{id}", get(get_car_by_id))
        .route("/api/cars", get(get_all_cars_handler))
        .route("/api/cars", post(create_car))
        .route("/api/auctions", get(get_auctions))
        .route("/api/auctions", post(create_auction))
        .route("/api/auctions/{id}", get(get_auction_by_id))
        .route("/api/bids", get(get_bids))
        .route("/api/bids", post(create_bid))
        .route("/api/bids/{id}", get(get_bid_by_id))
        //comment
        .route("/api/comments/{id}", get(get_comments))
        .route("/api/comment", post(create_comment))
        // save
        .route("/api/save_auction", post(create_saved_auction)) // save auction
        .route("/api/saved_auctions/{user}", get(get_saved_auctions_by_user)) // get user saved items
        .route("/api/auctions/saved/{id}", get(get_saved_auctions)) // get all saved by auction_id
        //init
        .route("/api/auctions/init", get(init_auction_handler))
        .route("/api/cars/init", get(init_car_handler))
        .route("/api/bids/init", get(init_bid_handler))
        .route("/api/db/init", get(init_overall_handler))
        .with_state(db);

    // Now you can use the entity types directly
    // for car in cars {
    //     println!("Car: {:?}", car);
    // }

    // print!("cars: {:?}", cars);
    // get_car_merkle_hash();
    // let db = Arc::new(db);
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber
        ::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    // let input: u32 = 15 * u32::pow(2, 27) + 1;
    // let input = get_car_leaves(cars)[0];
    // let env = ExecutorEnv::builder().write(&leaves).unwrap().build().unwrap();

    // Obtain the default prover.
    // let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover.prove(env, INIT_ELF).unwrap();

    // extract the receipt.
    // let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    // let output: AuctionState = receipt.journal.decode().unwrap();
    // print!("{:?}", output);
    // print!("{:?}", receipt);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    // receipt.verify(INIT_ID).unwrap();
    // Start the server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("Server running on http://0.0.0.0:3000");
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

// fn get_car_merkle_hash(cars: Vec<CarModel>) {
//     let mut leaves = vec![];
//     // let tree: Vec<&'static str> = vec!["s", "ss"];
//     for car in cars {
//         let car_record = format!(
//             "{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{}:{:?}:{}:{}",
//             car.id,
//             car.make,
//             car.model,
//             car.year,
//             car.color,
//             car.mileage,
//             car.vin,
//             car.transmission,
//             car.fuel_type,
//             car.engine_size,
//             car.exterior_color,
//             car.interior_color,
//             car.odometer,
//             car.description,
//             car.image_url,
//             car.auction_id,
//             car.starting_price,
//             car.current_price,
//             car.auction_status.clone().unwrap(),
//             // "status"
//             car.created_at.and_utc().timestamp(),
//             car.updated_at.and_utc().timestamp()
//         );
//         // car_record = format!("{{}}:{}:{}", id, id);
//         print!("{} \n", car_record);
//         leaves.push(sha256(car_record.as_bytes()));
//     }
//     // let le = format!(leaves.iter());
//     print!("{:?}", leaves[0])

//     // Ok(())
// }
